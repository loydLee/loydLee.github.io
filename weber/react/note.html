<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react 学习笔记 | loydLee&#39;s home</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.jpg">
    <meta name="description" content="我的小窝">
    
    <link rel="preload" href="/assets/css/0.styles.7fdd2b56.css" as="style"><link rel="preload" href="/assets/js/app.d5333c69.js" as="script"><link rel="preload" href="/assets/js/2.dd63acd8.js" as="script"><link rel="preload" href="/assets/js/37.f82d892e.js" as="script"><link rel="prefetch" href="/assets/js/10.f5b7ad67.js"><link rel="prefetch" href="/assets/js/11.bd28fe7a.js"><link rel="prefetch" href="/assets/js/12.cf2c28fd.js"><link rel="prefetch" href="/assets/js/13.cb068762.js"><link rel="prefetch" href="/assets/js/14.70b647de.js"><link rel="prefetch" href="/assets/js/15.f5ea1c53.js"><link rel="prefetch" href="/assets/js/16.9089d3fe.js"><link rel="prefetch" href="/assets/js/17.85a5207c.js"><link rel="prefetch" href="/assets/js/18.5f2e36da.js"><link rel="prefetch" href="/assets/js/19.d07d7334.js"><link rel="prefetch" href="/assets/js/20.8ff14cc4.js"><link rel="prefetch" href="/assets/js/21.200ced88.js"><link rel="prefetch" href="/assets/js/22.2ce3e3af.js"><link rel="prefetch" href="/assets/js/23.91bc20a6.js"><link rel="prefetch" href="/assets/js/24.1e9eb40a.js"><link rel="prefetch" href="/assets/js/25.647a7f39.js"><link rel="prefetch" href="/assets/js/26.82c6a3f4.js"><link rel="prefetch" href="/assets/js/27.da5f1f45.js"><link rel="prefetch" href="/assets/js/28.08e1f84c.js"><link rel="prefetch" href="/assets/js/29.1565e245.js"><link rel="prefetch" href="/assets/js/3.e5358e6d.js"><link rel="prefetch" href="/assets/js/30.f09b64b0.js"><link rel="prefetch" href="/assets/js/31.f102bba4.js"><link rel="prefetch" href="/assets/js/32.5a104702.js"><link rel="prefetch" href="/assets/js/33.e08c1bc1.js"><link rel="prefetch" href="/assets/js/34.7575c096.js"><link rel="prefetch" href="/assets/js/35.47c13ef3.js"><link rel="prefetch" href="/assets/js/36.90192c44.js"><link rel="prefetch" href="/assets/js/38.47359cb5.js"><link rel="prefetch" href="/assets/js/39.553e41b8.js"><link rel="prefetch" href="/assets/js/4.ee8516ba.js"><link rel="prefetch" href="/assets/js/40.8f62ea28.js"><link rel="prefetch" href="/assets/js/41.ebb4473c.js"><link rel="prefetch" href="/assets/js/42.86cff1a7.js"><link rel="prefetch" href="/assets/js/43.eeb871df.js"><link rel="prefetch" href="/assets/js/5.92ba487b.js"><link rel="prefetch" href="/assets/js/6.e4577d10.js"><link rel="prefetch" href="/assets/js/7.8f2c6af1.js"><link rel="prefetch" href="/assets/js/8.46fb09a3.js"><link rel="prefetch" href="/assets/js/9.1404eec2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7fdd2b56.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">loydLee's home</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/weber/electron/note.html" class="nav-link">
  前端er
</a></div><div class="nav-item"><a href="/other/note.html" class="nav-link">
  其他
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/weber/electron/note.html" class="nav-link">
  前端er
</a></div><div class="nav-item"><a href="/other/note.html" class="nav-link">
  其他
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端er</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>algorithm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>electron</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>react</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/weber/react/note.html" aria-current="page" class="active sidebar-link">react 学习笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/weber/react/note.html#jsx-语法" class="sidebar-link">JSX 语法</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#组件开发需要注意" class="sidebar-link">组件开发需要注意</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#状态-state" class="sidebar-link">状态(state)</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#组件的生命周期" class="sidebar-link">组件的生命周期</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#获取真实的-dom-节点" class="sidebar-link">获取真实的 dom 节点</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#组件通信" class="sidebar-link">组件通信</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#路由" class="sidebar-link">路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/weber/react/note.html#基础路由组件" class="sidebar-link">基础路由组件</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#路由路径语法" class="sidebar-link">路由路径语法</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#优先级" class="sidebar-link">优先级</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#histories" class="sidebar-link">Histories</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#默认路由-indexroute-与-indexlink" class="sidebar-link">默认路由(IndexRoute)与 IndexLink</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#动态路由" class="sidebar-link">动态路由</a></li></ul></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#flux-架构" class="sidebar-link">FLUX 架构</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#redux-架构" class="sidebar-link">Redux 架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/weber/react/note.html#基本概念" class="sidebar-link">基本概念</a></li></ul></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#react-踩坑" class="sidebar-link">react 踩坑</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#父子传值" class="sidebar-link">父子传值</a></li><li class="sidebar-sub-header"><a href="/weber/react/note.html#proptypes" class="sidebar-link">PropTypes</a></li></ul></li><li><a href="/weber/react/react-native.html" class="sidebar-link">react native</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>正则</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>typescript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/other/note.html" class="sidebar-link">随记</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-学习笔记"><a href="#react-学习笔记" class="header-anchor">#</a> react 学习笔记</h1> <h2 id="jsx-语法"><a href="#jsx-语法" class="header-anchor">#</a> JSX 语法</h2> <p>html 语言直接写在 javascript 语言之中，不加任何引号，这就是 jsx 的语法，它允许 html 与 javascript 的混写</p> <p>jsx 的基本语法规则：遇到 html 标签（以&lt;开头），就用 html 规则解析，遇到代码块（以{开头），就用 javascript 规则解析</p> <h2 id="组件开发需要注意"><a href="#组件开发需要注意" class="header-anchor">#</a> 组件开发需要注意</h2> <div class="language- extra-class"><pre class="language-text"><code>获取属性的值用的是this.props属性名，它与组件的属性一一对应，但是有一个例外，就是this.props.children，它表示组件的所有子节点
创建的组件名称首字母必须大写
为元素添加css的class时，要用className，fot属性需要写成htmlFor，因为class和for是javascript的保留字
组件类只能包含一个顶层标签
组件的style属性的设置方式也值得注意，要写成style={{width:this.state.width}}
</code></pre></div><h2 id="状态-state"><a href="#状态-state" class="header-anchor">#</a> 状态(state)</h2> <ul><li>getInitialState 函数必须有返回值</li> <li><ul><li>getInitialState 函数必须有返回值，可以是 null 或者一个对象</li></ul></li> <li><ul><li>访问 state 的方法是 this.state.属性名</li></ul></li> <li><ul><li>变量用{}包裹，不需要再加双引号</li></ul></li></ul> <h2 id="组件的生命周期"><a href="#组件的生命周期" class="header-anchor">#</a> 组件的生命周期</h2> <ul><li>Mounting:已插入真实 DOM</li> <li>Updating：正在被重新渲染</li> <li>Unmounting：已移出真实 DOM</li></ul> <p>React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">componentWillUpdate</span><span class="token punctuation">(</span>object nextProps<span class="token punctuation">,</span> object nextState<span class="token punctuation">)</span>
<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>object prevProps<span class="token punctuation">,</span> object prevState<span class="token punctuation">)</span>
<span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>此外，React 还提供两种特殊状态的处理函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span>object nextProps<span class="token punctuation">)</span>：已加载组件收到新的参数时调用
<span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>object nextProps<span class="token punctuation">,</span> object nextState<span class="token punctuation">)</span>：组件判断是否重新渲染时调用
</code></pre></div><h2 id="获取真实的-dom-节点"><a href="#获取真实的-dom-节点" class="header-anchor">#</a> 获取真实的 dom 节点</h2> <p>组件并不是真实的 dom 节点，而是存在于内存之中的一种数据结构，叫做虚拟 dom，只有当他插入文档以后，才会变成真实的 dom,react：所有的 dom 变动，都在 dom 上发生，然后再将实际发生变动的地方，真实的反映在 dom 上</p> <p>然而有时候我们需要获取真实 dom 的节点-ref 属性</p> <p>例：有一个文本输入框，需要获取用户的输入，这时候必须获取真实的 dom 节点，因为虚拟 dom 拿不到用户输入，因此文本输入框必须有一个 ref 属性，然后通过 this.refs.[refName]获取这个真实的 dom 节点，但是需要注意，由于 this.refs.[refName]属性获取的是真实 dom，所以必须等到虚拟 dom 插入文档以后，才能使用这个属性，否则会报错</p> <h2 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h2> <p>需要注意的是，react 不同于 vue 具有父子数据双向(虽然这在 vue2 之后也不被推荐使用),react 想要与父组件通信，首先需要父组件通过 props 传递方法给子组件，当有需要的时候，子组件去调用这个方法，告知父组件子组件的状态发生改变了</p> <h2 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h2> <blockquote><p>需要注意的是，react-router 4.x 之后，很多 api 产生了变化，而网上的实例以及大多数内容都是 4.x 之前的版本，所以涉及到一些写法需要格外注意</p></blockquote> <h3 id="基础路由组件"><a href="#基础路由组件" class="header-anchor">#</a> 基础路由组件</h3> <ul><li>Router-主要路由组件，用来声明一个路由内容(区块？)</li> <li>Route-路由子单元，路由对象由一个个 Route 子单元构成，它的参数包含 path-路由地址(页面访问用到的地址)---这儿需要注意，如果是子路由的形式，没有用绝对路由地址的话访问到的路由地址包含其父级链接，与之相对，绝对地址访问到的 url 不包含父级地址</li> <li>Link-组件跳转用，参数 to 跟路由地址</li> <li>Redirect-重定向，参数 from、to:表示访问前者的路由地址会自动渲染后者地址的内容</li></ul> <h3 id="路由路径语法"><a href="#路由路径语法" class="header-anchor">#</a> 路由路径语法</h3> <p>路由路径是匹配一个(或者一部分)URL 的一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号：</p> <ul><li>:paramName-匹配一段位于/、?或#之后的 url。命中的部分将被作为一个参数</li> <li>()-在它内部的内容被认为是可选的</li> <li>*- 匹配任意字符(非贪婪的)直到命中下一个字符或者整个 url 的末尾，并创建一个 splat 参数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;Route path=&quot;/hello/:name&quot;&gt;         // 匹配 /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/hello(/:name)&quot;&gt;       // 匹配 /hello, /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/files/*.*&quot;&gt;           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg
</code></pre></div><blockquote><p>注意：如果一个路由使用了相对路径，那么完整的路径将由它的所有祖先节点的路径和自身指定的相对路径拼接而成，使用绝对路径可以使路由匹配行为忽略嵌套关系</p></blockquote> <h3 id="优先级"><a href="#优先级" class="header-anchor">#</a> 优先级</h3> <p>路由算法会根据定义的顺序自顶向下匹配路由，因此当拥有两个兄弟路由节点配置时,我们必须确认前一个路由不会匹配后一个路由中的路径，千万不要这么做：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;Route path=&quot;/comments&quot; ... /&gt;
&lt;Redirect from=&quot;/comments&quot; ... /&gt;
</code></pre></div><h3 id="histories"><a href="#histories" class="header-anchor">#</a> Histories</h3> <p>React Router 是建立在 history 之上的，简而言之，一个 history 知道如何去监听浏览器地址栏的变化，并解析这个 url 转化为 location 对象，然后 router 使用它匹配到路由，最后正确的渲染对应的组件</p> <p>常见的 history 三种形式：(当然也可以使用 React Router 实现自定义的 history)</p> <p>引用</p> <div class="language- extra-class"><pre class="language-text"><code>import { browserHistory } from 'react-router'
</code></pre></div><p>使用</p> <div class="language- extra-class"><pre class="language-text"><code>render(
  &lt;Router history={browserHistory} routes={routes} /&gt;,
  document.getElementById('app')
)
</code></pre></div><ul><li><p>browserHistory</p> <p>Browser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像 example.com/some/path 这样真实的 URL 。</p></li> <li><p>hashHistory</p> <div class="language- extra-class"><pre><code>Hash history 使用 URL 中的 hash（#）部分去创建形如 example.com/#/some/path 的路由。
</code></pre></div><blockquote><p>createHashHistory-Hash history 不需要服务器任何配置就可以运行,但是不推荐在实际线上环境中用到它，因为每一个 web 应用都应该渴望使用 browserHistory</p></blockquote></li> <li><p>createMemoryHistory
Memory history 不会在地址栏被操作或读取。这就解释了我们是如何实现服务器渲染的。同时它也非常适合测试和其他的渲染环境（像 React Native ）。</p></li></ul> <p>和另外两种 history 的一点不同是你必须创建它，这种方式便于测试。</p> <div class="language- extra-class"><pre class="language-text"><code>const history = createMemoryHistory(location)
</code></pre></div><h3 id="默认路由-indexroute-与-indexlink"><a href="#默认路由-indexroute-与-indexlink" class="header-anchor">#</a> 默认路由(IndexRoute)与 IndexLink</h3> <div class="language- extra-class"><pre class="language-text"><code>IndexRoute-参数为component：默认渲染的组件
Index Links-如果在这个 app 中使用 &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; , 它会一直处于激活状态，因为所有的 URL 的开头都是 / 。 这确实是个问题，因为我们仅仅希望在 Home 被渲染后，激活并链接到它。如果需要在 Home 路由被渲染后才激活的指向 / 的链接，请使用 &lt;IndexLink to=&quot;/&quot;&gt;Home&lt;/IndexLink&gt;
</code></pre></div><h3 id="动态路由"><a href="#动态路由" class="header-anchor">#</a> 动态路由</h3> <p>React Router 的路径匹配以及组件加载都是异步完成的，不仅仅允许延迟加载组件，并且可以延迟加载理由设置，在首次加载包中只需要有一个路径定义，路由会自动解析剩下的路径</p> <p>Route 可以定义 getChildRoutes，getIndexRoute 和 getComponents 这几个函数。它们都是异步执行，并且只有在需要时才被调用。我们将这种方式称之为 “逐渐匹配”。 React Router 会逐渐的匹配 URL 并只加载该 URL 对应页面所需的路径配置和组件。</p> <div class="language- extra-class"><pre class="language-text"><code>const CourseRoute = {
  path: 'course/:courseId',

  getChildRoutes(location, callback) {
    require.ensure([], function (require) {
      callback(null, [
        require('./routes/Announcements'),
        require('./routes/Assignments'),
        require('./routes/Grades'),
      ])
    })
  },

  getIndexRoute(location, callback) {
    require.ensure([], function (require) {
      callback(null, require('./components/Index'))
    })
  },

  getComponents(location, callback) {
    require.ensure([], function (require) {
      callback(null, require('./components/Course'))
    })
  }
}
</code></pre></div><p>因此定义组件可以：</p> <div class="language- extra-class"><pre class="language-text"><code>const more = (location, callback) =&gt; {
    require.ensure([], require =&gt; {
        callback(null, require('../Component/more').default)
    },'more')
}
</code></pre></div><h2 id="flux-架构"><a href="#flux-架构" class="header-anchor">#</a> FLUX 架构</h2> <p>flux 把一个应用分成四个部分：</p> <ul><li>View:视图层</li> <li>Action(动作):视图层发出的消息(比如 mouseClick)</li> <li>Dispatcher(派发器)：用来接收 Actions、执行回调函数</li> <li>Store(数据层):用来存放应用的状态，一旦发生变动，就提醒 Views 要更新页面</li></ul> <p>FLUX 最大特点：数据单向流动</p> <blockquote><p>用户访问 View</p></blockquote> <blockquote><p>View 发出用户的 Action</p></blockquote> <blockquote><p>Dispatcher 收到 Action，要求 Store 进行相应的更新</p></blockquote> <blockquote><p>Store 更新后，发出一个&quot;change&quot;事件</p></blockquote> <blockquote><p>View 收到&quot;change&quot;事件后，更新页面</p></blockquote> <h2 id="redux-架构"><a href="#redux-架构" class="header-anchor">#</a> Redux 架构</h2> <p>需要使用的场景-多交互，多数据源</p> <ul><li>用户的使用方式复杂</li> <li>不同身份的用户有不同的使用方式(比如普通用户和管理员)</li> <li>多个用户之间可以协作</li> <li>与服务器大量交互，或者使用了 websocket</li> <li>view 要从多个来源获取数据</li></ul> <p>组件角度看，以下场景可以考虑使用 redux</p> <ul><li>某个组件的状态，需要共享</li> <li>某个状态需要在任何地方都可以拿到</li> <li>一个组件需要改变全局状态</li> <li>一个组件需要改变另一个组件的状态</li></ul> <blockquote><p>设计思想</p></blockquote> <ul><li>web 应用是一个状态机，视图和状态是一一对应的</li> <li>所有的状态，保存在一个对象里面</li></ul> <h3 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h3> <blockquote><p>store 保存数据的地方</p></blockquote> <p>Redux 提供 createStore 这个函数，用来生成 Store,createStore 函数接受另一个函数作为参数，返回新生成的 Store 对象</p> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from 'redux';
const store = createStore(fn);
</code></pre></div><blockquote><p>State-Store 对象包含所有数据，如果想要得到某个时点的数据，对 Store 生成快照的数据集合</p></blockquote> <p>当前时刻的 State,可以通过 store.getState 拿到</p> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from 'redux';
const store = createStore(fn);

const state = store.getState();
</code></pre></div><p>Redux 规定，一个 State 对应一个 View,只要 State 相同，View 就相同</p> <blockquote><p>Action-State 的变化，会导致 View 的变化，但是用户接触不到 State，只能接触到 View，所以 State 的变化必须是 View 导致的，Action 就是 View 发出的通知，表示 State 应该要发生变化了</p></blockquote> <p>action 是一个对象，其中的 type 属性是必须的，表示 Action 的名称，其他属性可以自由设置，下面代码中，Action 的名称是 ADD_TODO，携带的信息是字符串 Learn Redux，Action 描述当前发生的事情，改变 State 的唯一办法，就是使用 Action,它会运送数据到 Store</p> <div class="language- extra-class"><pre class="language-text"><code>const action = {
  type: 'ADD_TODO',
  payload: 'Learn Redux'
};
</code></pre></div><blockquote><p>Action Creator-View 要发送多少种消息，就会有多少种 Action，Action Creator 用来生成 Action</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const ADD_TODO = '添加 TODO';

function addTodo(text) {
  return {
    type: ADD_TODO,
    text
  }
}

const action = addTodo('Learn Redux');
</code></pre></div><blockquote><p>store.dispatch()-View 发出 Action 的唯一方法,</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from 'redux';
const store = createStore(fn);

store.dispatch({
  type: 'ADD_TODO',
  payload: 'Learn Redux'
});
</code></pre></div><p>结合 Action Creator</p> <div class="language- extra-class"><pre class="language-text"><code>store.dispatch(addTodo('Learn Redux'));
</code></pre></div><blockquote><p>Reducer-Store 收到 action 以后，必须给出一个新的 State,这样 View 才会发生变化，Reducer 是一个计算的过程，但是同时，它也是一个函数，接受 Action 和当前 State 作为参数，返回一个新的 State</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const reducer = function (state, action) {
  // ...
  return new_state;
};
</code></pre></div><h1 id="react-基础"><a href="#react-基础" class="header-anchor">#</a> react 基础</h1> <h2 id="react-踩坑"><a href="#react-踩坑" class="header-anchor">#</a> react 踩坑</h2> <p>Fragment</p> <p>与 vue 一样，react 规定最外层保持单一元素包裹，但是使用 div 这种时候有时候会破坏布局，react16 之后增加：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Fragment <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>className</p> <p>jsx 中 class 避免与 js 的 class 冲突修正为 className</p> <p>dangerouslySetInnerHTML</p> <div class="language-js extra-class"><pre class="language-js"><code>渲染html字段
<span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>li
          key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token operator">+</span>item<span class="token punctuation">}</span>
          onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteItem</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">}</span>
          dangerouslySetInnerHTML<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>__html<span class="token operator">:</span>item<span class="token punctuation">}</span><span class="token punctuation">}</span>
        <span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
</code></pre></div><p>label for -&gt; htmlFor</p> <h2 id="父子传值"><a href="#父子传值" class="header-anchor">#</a> 父子传值</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 父-子：通过组件上props直接传递，可以传递属性也可以传递方法， 传递方法的时候注意绑定this</span>
 <span class="token operator">&lt;</span>div key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>XiaojiejieItem
      content<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span>
      index<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span>
      deleteItem<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteItem</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>XiaojiejieItem<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token comment">// 子-父：通过props传递来的方法进行调用</span>
<span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">deleteItem</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>index<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="proptypes"><a href="#proptypes" class="header-anchor">#</a> PropTypes</h2> <p>开发中我们会限制 props 的类别</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> PropTypes <span class="token keyword">from</span> <span class="token string">&quot;prop-types&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 然后在组件的下方进行引用</span>
XiaojiejieItem<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  content<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>string<span class="token punctuation">.</span>isRequired<span class="token punctuation">,</span>
  deleteItem<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>func<span class="token punctuation">,</span>
  index<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>number
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 默认值</span>
XiaojiejieItem<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>
  avname<span class="token operator">:</span> <span class="token string">&quot;test&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">10/19/2021, 11:33:07 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/weber/js/underscore之防抖节流.html" class="prev">
        underscore之防抖节流
      </a></span> <span class="next"><a href="/weber/react/react-native.html">
        react native
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div class="cat-container" data-v-a13867c0><canvas id="vuepress-cat" width="280" height="250" class="live2d" data-v-a13867c0></canvas></div></div></div>
    <script src="/assets/js/app.d5333c69.js" defer></script><script src="/assets/js/2.dd63acd8.js" defer></script><script src="/assets/js/37.f82d892e.js" defer></script>
  </body>
</html>
