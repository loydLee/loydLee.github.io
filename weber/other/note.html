<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端笔记 | loydLee&#39;s home</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.jpg">
    <meta name="description" content="我的小窝">
    
    <link rel="preload" href="/assets/css/0.styles.7fdd2b56.css" as="style"><link rel="preload" href="/assets/js/app.d5333c69.js" as="script"><link rel="preload" href="/assets/js/2.dd63acd8.js" as="script"><link rel="preload" href="/assets/js/34.7575c096.js" as="script"><link rel="prefetch" href="/assets/js/10.f5b7ad67.js"><link rel="prefetch" href="/assets/js/11.bd28fe7a.js"><link rel="prefetch" href="/assets/js/12.cf2c28fd.js"><link rel="prefetch" href="/assets/js/13.cb068762.js"><link rel="prefetch" href="/assets/js/14.70b647de.js"><link rel="prefetch" href="/assets/js/15.f5ea1c53.js"><link rel="prefetch" href="/assets/js/16.9089d3fe.js"><link rel="prefetch" href="/assets/js/17.85a5207c.js"><link rel="prefetch" href="/assets/js/18.5f2e36da.js"><link rel="prefetch" href="/assets/js/19.d07d7334.js"><link rel="prefetch" href="/assets/js/20.8ff14cc4.js"><link rel="prefetch" href="/assets/js/21.200ced88.js"><link rel="prefetch" href="/assets/js/22.2ce3e3af.js"><link rel="prefetch" href="/assets/js/23.91bc20a6.js"><link rel="prefetch" href="/assets/js/24.1e9eb40a.js"><link rel="prefetch" href="/assets/js/25.647a7f39.js"><link rel="prefetch" href="/assets/js/26.82c6a3f4.js"><link rel="prefetch" href="/assets/js/27.da5f1f45.js"><link rel="prefetch" href="/assets/js/28.08e1f84c.js"><link rel="prefetch" href="/assets/js/29.1565e245.js"><link rel="prefetch" href="/assets/js/3.e5358e6d.js"><link rel="prefetch" href="/assets/js/30.f09b64b0.js"><link rel="prefetch" href="/assets/js/31.f102bba4.js"><link rel="prefetch" href="/assets/js/32.5a104702.js"><link rel="prefetch" href="/assets/js/33.e08c1bc1.js"><link rel="prefetch" href="/assets/js/35.47c13ef3.js"><link rel="prefetch" href="/assets/js/36.90192c44.js"><link rel="prefetch" href="/assets/js/37.f82d892e.js"><link rel="prefetch" href="/assets/js/38.47359cb5.js"><link rel="prefetch" href="/assets/js/39.553e41b8.js"><link rel="prefetch" href="/assets/js/4.ee8516ba.js"><link rel="prefetch" href="/assets/js/40.8f62ea28.js"><link rel="prefetch" href="/assets/js/41.ebb4473c.js"><link rel="prefetch" href="/assets/js/42.86cff1a7.js"><link rel="prefetch" href="/assets/js/43.eeb871df.js"><link rel="prefetch" href="/assets/js/5.92ba487b.js"><link rel="prefetch" href="/assets/js/6.e4577d10.js"><link rel="prefetch" href="/assets/js/7.8f2c6af1.js"><link rel="prefetch" href="/assets/js/8.46fb09a3.js"><link rel="prefetch" href="/assets/js/9.1404eec2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7fdd2b56.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">loydLee's home</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/weber/electron/note.html" class="nav-link">
  前端er
</a></div><div class="nav-item"><a href="/other/note.html" class="nav-link">
  其他
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/weber/electron/note.html" class="nav-link">
  前端er
</a></div><div class="nav-item"><a href="/other/note.html" class="nav-link">
  其他
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端er</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>algorithm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>electron</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>正则</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>typescript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>其他</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/weber/other/note.html" aria-current="page" class="active sidebar-link">前端笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/weber/other/note.html#xml-与-json-的区别" class="sidebar-link">XML 与 JSON 的区别</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#如何解决跨域问题" class="sidebar-link">如何解决跨域问题</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#webpack-的两大特色" class="sidebar-link">webpack 的两大特色</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#tcp-传输的三次握手四次挥手策略" class="sidebar-link">TCP 传输的三次握手四次挥手策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/weber/other/note.html#三次握手" class="sidebar-link">三次握手</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#四次挥手" class="sidebar-link">四次挥手</a></li></ul></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#tcp-与-udp-的区别" class="sidebar-link">TCP 与 UDP 的区别</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#作用域链" class="sidebar-link">作用域链</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#原生创建-ajax-的过程" class="sidebar-link">原生创建 ajax 的过程</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#渐进增强与优雅降级" class="sidebar-link">渐进增强与优雅降级</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#常见-web-安全以及防护原理" class="sidebar-link">常见 web 安全以及防护原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/weber/other/note.html#sql-注入" class="sidebar-link">sql 注入</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#xss-原理及防范" class="sidebar-link">XSS 原理及防范</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#xss-与-csrf-区别" class="sidebar-link">XSS 与 CSRF 区别</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#通过验证码的方法进行" class="sidebar-link">通过验证码的方法进行</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#http-与-https" class="sidebar-link">HTTP 与 HTTPS</a></li></ul></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#对前端模块化的认识" class="sidebar-link">对前端模块化的认识</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#javascript-的垃圾回收方法" class="sidebar-link">javascript 的垃圾回收方法</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#性能优化" class="sidebar-link">性能优化</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#js-继承方式及其优缺点" class="sidebar-link">js 继承方式及其优缺点</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#http-2-0" class="sidebar-link">HTTP 2.0</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#defer-与-async" class="sidebar-link">defer 与 async</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#设计模式" class="sidebar-link">设计模式</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#对闭包的理解" class="sidebar-link">对闭包的理解</a></li><li class="sidebar-sub-header"><a href="/weber/other/note.html#cookie-的弊端" class="sidebar-link">cookie 的弊端</a></li></ul></li><li><a href="/weber/other/基于飞冰的微前端实践.html" class="sidebar-link">微前端</a></li><li><a href="/weber/other/基于qiankun的微前端实践.html" class="sidebar-link">基于qiankun的微前端实践</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/other/note.html" class="sidebar-link">随记</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前端笔记"><a href="#前端笔记" class="header-anchor">#</a> 前端笔记</h1> <h2 id="xml-与-json-的区别"><a href="#xml-与-json-的区别" class="header-anchor">#</a> XML 与 JSON 的区别</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、数据体积方面
   <span class="token constant">JSON</span>相对于<span class="token constant">XML</span>来说，数据的体积小，传递的速度更快些
<span class="token number">2</span>、数据交互方面
   <span class="token constant">JSON</span>与javascript的交互更加方便，更容易解析处理，更好的数据交互
<span class="token number">3</span>、数据描述方面
   <span class="token constant">JSON</span>对数据的描述性比<span class="token constant">XML</span>较差
<span class="token number">4</span>、传输速度方面
   <span class="token constant">JSON</span>的速度远远快于<span class="token constant">XML</span>
</code></pre></div><h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="header-anchor">#</a> 如何解决跨域问题</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、<span class="token constant">JSONP</span>
   原理：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信，缺点为只支持<span class="token keyword">get</span>请求
<span class="token number">2</span>、cros
   服务器端对于<span class="token constant">CORS</span>的支持，主要就是通过设置Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问
<span class="token number">3</span>、通过修改document<span class="token punctuation">.</span>domain来跨子域
   将子域和主域的document<span class="token punctuation">.</span>domain设为同一个主域<span class="token punctuation">.</span>前提条件：这两个域名必须属于同一个基础域名<span class="token operator">!</span>而且所用的协议，端口都要一致，否则无法利用document<span class="token punctuation">.</span>domain进行跨域
   主域相同的使用document<span class="token punctuation">.</span>domain
<span class="token number">4</span>、使用window<span class="token punctuation">.</span>name来进行跨域
   <span class="token function">window对象有个name属性，该属性有个特征：即在一个窗口</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span>的生命周期内<span class="token punctuation">,</span>窗口载入的所有的页面都是共享一个window<span class="token punctuation">.</span>name的，每个页面对window<span class="token punctuation">.</span>name都有读写的权限，window<span class="token punctuation">.</span>name是持久存在一个窗口载入过的所有页面中的
<span class="token number">5</span>、使用<span class="token constant">HTML5</span>中新引进的window<span class="token punctuation">.</span>postMessage方法来跨域传送数据

   除此之外，还有flash，，在服务器上这是代理页面等跨域方式，其中，window<span class="token punctuation">.</span>name的方法既不复杂，又能兼容到所有的浏览器。<span class="token operator">**</span>推荐使用<span class="token operator">**</span>
</code></pre></div><h2 id="webpack-的两大特色"><a href="#webpack-的两大特色" class="header-anchor">#</a> webpack 的两大特色</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、code <span class="token function">splitting</span><span class="token punctuation">(</span>可以自动完成<span class="token punctuation">)</span>
<span class="token number">2</span>、loader可以处理各种类型的静态文件，并且支持串联操作
</code></pre></div><p>webpack 具有 requirejs 以及 browserify 的功能，但是还有很多自己的特性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、对commonjs、amd、es6的语法做了兼容
<span class="token number">2</span>、对js、css、图片等资源文件都支持打包
<span class="token number">3.</span> 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、<span class="token constant">ES6</span>的支持

<span class="token number">4.</span> 有独立的配置文件webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js

<span class="token number">5.</span> 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间

<span class="token number">6.</span> 支持 SourceUrls 和 SourceMaps，易于调试

<span class="token number">7.</span> 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活

<span class="token number">8.</span>webpack 使用异步 <span class="token constant">IO</span> 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快
</code></pre></div><h2 id="tcp-传输的三次握手四次挥手策略"><a href="#tcp-传输的三次握手四次挥手策略" class="header-anchor">#</a> TCP 传输的三次握手四次挥手策略</h2> <h3 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h3> <div class="language-js extra-class"><pre class="language-js"><code>为了准确无误地把数据送达目标处，<span class="token constant">TCP</span>协议采用了三次握手策略。用<span class="token constant">TCP</span>协议把数据包送出去后，<span class="token constant">TCP</span>不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了<span class="token constant">TCP</span>的标志：<span class="token constant">SYN</span>和<span class="token constant">ACK</span>。

发送端首先发送一个带<span class="token constant">SYN</span>标志的数据包给对方。接收端收到后，回传一个带有<span class="token constant">SYN</span><span class="token operator">/</span><span class="token constant">ACK</span>标志的数据包以示传达确认信息。
最后，发送端再回传一个带<span class="token constant">ACK</span>标志的数据包，代表“握手”结束。
若在握手过程中某个阶段莫名中断，<span class="token constant">TCP</span>协议会再次以相同的顺序发送相同的数据包。
</code></pre></div><h3 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h3> <div class="language-js extra-class"><pre class="language-js"><code>第一次挥手：主动关闭方发送一个<span class="token constant">FIN</span>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 <span class="token function">会再给你发数据了</span><span class="token punctuation">(</span>当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据<span class="token punctuation">)</span>，但是，此时主动关闭方还可 以接受数据。

第二次挥手：被动关闭方收到<span class="token constant">FIN</span>包后，发送一个<span class="token constant">ACK</span>给对方，确认序号为收到序号<span class="token operator">+</span><span class="token number">1</span>（与<span class="token constant">SYN</span>相同，一个<span class="token constant">FIN</span>占用一个序号）。

第三次挥手：被动关闭方发送一个<span class="token constant">FIN</span>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到<span class="token constant">FIN</span>后，发送一个<span class="token constant">ACK</span>给被动关闭方，确认序号为收到序号<span class="token operator">+</span><span class="token number">1</span>，至此，完成四次挥手。
</code></pre></div><h2 id="tcp-与-udp-的区别"><a href="#tcp-与-udp-的区别" class="header-anchor">#</a> TCP 与 UDP 的区别</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">TCP</span>（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个<span class="token constant">TCP</span>连接必须要经过三次“对话”才能建立起来

<span class="token constant">UDP</span>（User Data Protocol，用户数据报协议）是与<span class="token constant">TCP</span>相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
<span class="token constant">UDP</span>适用于一次只传送少量数据、对可靠性要求不高的应用环境。
</code></pre></div><h2 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h2> <p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的</p> <h2 id="原生创建-ajax-的过程"><a href="#原生创建-ajax-的过程" class="header-anchor">#</a> 原生创建 ajax 的过程</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span>、创建XMLHttpRequest对象<span class="token punctuation">,</span>也就是创建一个异步调用对象<span class="token punctuation">.</span>

<span class="token number">2</span>、创建一个新的<span class="token constant">HTTP</span>请求<span class="token punctuation">,</span>并指定该<span class="token constant">HTTP</span>请求的方法、<span class="token constant">URL</span>及验证信息<span class="token punctuation">.</span>

<span class="token number">3</span>、设置响应<span class="token constant">HTTP</span>请求状态变化的函数<span class="token punctuation">.</span>

<span class="token number">4</span>、发送<span class="token constant">HTTP</span>请求<span class="token punctuation">.</span>

<span class="token number">5</span>、获取异步调用返回的数据<span class="token punctuation">.</span>

<span class="token number">6</span>、使用JavaScript和<span class="token constant">DOM</span>实现局部刷新<span class="token punctuation">.</span>
</code></pre></div><h2 id="渐进增强与优雅降级"><a href="#渐进增强与优雅降级" class="header-anchor">#</a> 渐进增强与优雅降级</h2> <div class="language-js extra-class"><pre class="language-js"><code>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
</code></pre></div><h2 id="常见-web-安全以及防护原理"><a href="#常见-web-安全以及防护原理" class="header-anchor">#</a> 常见 web 安全以及防护原理</h2> <h3 id="sql-注入"><a href="#sql-注入" class="header-anchor">#</a> sql 注入</h3> <p>通过 sql 命令把表单提交到或输入域名或页面请求的查询字符串，以达到欺骗服务器执行恶意的 sql 命令
总体如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<span class="token string">&quot;-&quot;</span>进行转换等。
<span class="token number">2.</span>永远不要使用动态拼装<span class="token constant">SQL</span>，可以使用参数化的<span class="token constant">SQL</span>或者直接使用存储过程进行数据查询存取。
<span class="token number">3.</span>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
<span class="token number">4.</span>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。
</code></pre></div><h3 id="xss-原理及防范"><a href="#xss-原理及防范" class="header-anchor">#</a> XSS 原理及防范</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">Xss</span><span class="token punctuation">(</span>cross<span class="token operator">-</span>site scripting<span class="token punctuation">)</span>攻击指的是攻击者往web页面里插入恶意html或者javascript代码，比如：攻击者在论坛中放一个看似安全的链接，片区用户点击后，窃取cookie的用户私密信息，或者攻击者在了论坛中加一个恶意表单；
当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

防范方法<span class="token operator">:</span>
        首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<span class="token operator">&lt;</span>”<span class="token punctuation">,</span>”<span class="token operator">&gt;</span>”<span class="token punctuation">,</span>”<span class="token punctuation">;</span>”<span class="token punctuation">,</span>”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心吧hrml tag弄出来
        然而，避免直接在cookie中泄露用户隐私，例如email<span class="token punctuation">,</span>密码等等
        其次，通过cookie和系统ip绑定来降低cookie泄露后的危险，这样攻击者得到的cookie没有实际价值，如果网站不需要在浏览器端对cookie进行操作，可以在set<span class="token operator">-</span>cookie末尾加上httponly来防止javascript代码直接获取cookie
</code></pre></div><h3 id="xss-与-csrf-区别"><a href="#xss-与-csrf-区别" class="header-anchor">#</a> XSS 与 CSRF 区别</h3> <p>XSS 是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF 是代替用户完成指定的动作，需要知道 ITA 用户页面的代码和数据包，而要完成一次 CSRF 攻击，受害者必须一次完成两个步骤:</p> <div class="language-js extra-class"><pre class="language-js"><code>登录受信任网站<span class="token constant">A</span>，并在本地生成cookie
在不登出<span class="token constant">A</span>的情况下，访问危险网站<span class="token constant">B</span>
</code></pre></div><p>CSRF 的防御：服务端的 CSRF 方法有很多，思路一致：在客户端页面增加伪随机数</p> <h3 id="通过验证码的方法进行"><a href="#通过验证码的方法进行" class="header-anchor">#</a> 通过验证码的方法进行</h3> <p>web worker 和 websocket</p> <div class="language-js extra-class"><pre class="language-js"><code>worker主线程：
            <span class="token number">1.</span>通过 worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span> url <span class="token punctuation">)</span> 加载一个<span class="token constant">JS</span>文件来创建一个worker，同时返回一个worker实例。

            <span class="token number">2.</span>通过worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span> data <span class="token punctuation">)</span> 方法来向worker发送数据。

            <span class="token number">3.</span>绑定worker<span class="token punctuation">.</span>onmessage方法来接收worker发送过来的数据。

            <span class="token number">4.</span>可以使用 worker<span class="token punctuation">.</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 来终止一个worker的执行。
websocket是web应用程序的传输协议，它提供了双向的，按序到达的数据流，其次，它是一个html5协议，websocket的链接是持久的，通过在客户端和服务器之间保持双工链接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询
</code></pre></div><h3 id="http-与-https"><a href="#http-与-https" class="header-anchor">#</a> HTTP 与 HTTPS</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTTP</span>协议通常承载于<span class="token constant">TCP</span>协议之上，在<span class="token constant">HTTP</span>和<span class="token constant">TCP</span>之间添加一个安全协议层（<span class="token constant">SSL</span>或<span class="token constant">TSL</span>），这个时候，就成了<span class="token constant">HTTPS</span>。

默认<span class="token constant">HTTP</span>的端口号为<span class="token number">80</span>，<span class="token constant">HTTPS</span>的端口号为<span class="token number">443</span>。

为什么<span class="token constant">HTTPS</span>安全

因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用<span class="token constant">HTTPS</span>，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl<span class="token operator">/</span>tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性
</code></pre></div><h2 id="对前端模块化的认识"><a href="#对前端模块化的认识" class="header-anchor">#</a> 对前端模块化的认识</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">AMD</span>是requirejs在推广过程中对模块定义的规范化中产出，它是提前执行，推荐的风格是返回一个对象作为模块对象
Commonjs是seajs在推广过程中对模块定的的规范化中产出，它是延迟执行，commonjs的风格通过对module，exports或exports的属性复制来达到暴露模块对象的目的
</code></pre></div><h2 id="javascript-的垃圾回收方法"><a href="#javascript-的垃圾回收方法" class="header-anchor">#</a> javascript 的垃圾回收方法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">标记清除</span><span class="token punctuation">(</span>mark and sweep<span class="token punctuation">)</span>
    <span class="token function">javascript最常见的垃圾回收，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为‘进入环境’，当变量离开环境的时候</span><span class="token punctuation">(</span>函数执行结束<span class="token punctuation">)</span>将其标记为‘离开环境’
    <span class="token function">垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量</span><span class="token punctuation">(</span>闭包<span class="token punctuation">)</span>，在这些完成之后仍存在标记的就是要删除的变量
<span class="token function">引用计数</span><span class="token punctuation">(</span>reference counting<span class="token punctuation">)</span>
    在低版本<span class="token constant">IE</span>中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加<span class="token number">1</span>，如果该变量的值变成了另外一个，则这个值得引用次数减<span class="token number">1</span>，当这个值的引用次数变为<span class="token number">0</span>的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为<span class="token number">0</span>的值占用的空间。

    在<span class="token constant">IE</span>中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但<span class="token constant">BOM</span>与<span class="token constant">DOM</span>对象却是通过引用计数回收垃圾的，
    也就是说只要涉及<span class="token constant">BOM</span>及<span class="token constant">DOM</span>就会出现循环引用问题。
</code></pre></div><h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <div class="language-js extra-class"><pre class="language-js"><code>代码层面优化
    用hash<span class="token operator">-</span>table来优化查找
    少用全局变量
    用innerHTML代替<span class="token constant">DOM</span>操作，减少<span class="token constant">DOM</span>操作次数，优化javascript性能
    用setTimeout避免页面失去响应
    缓存<span class="token constant">DOM</span>节点查找结果
    避免使用css expression
    避免全局查询
    避免使用<span class="token keyword">with</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">with</span>会创建自己的作用域，会增加作用域链长度<span class="token punctuation">)</span>
    多个变量声明合并
    避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率
    尽量避免写在<span class="token constant">HTML</span>标签中写Style属性

移动端性能优化
    尽量使用css3动画，开启硬件加速。
    适当使用touch事件代替click事件。
    避免使用css3渐变阴影效果。
    可以用transform<span class="token operator">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>来开启硬件加速。
    不滥用Float。Float在渲染时计算量比较大，尽量减少使用
    不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。
    合理使用requestAnimationFrame动画代替setTimeout
    <span class="token constant">CSS</span>中的属性（<span class="token constant">CSS3</span> transitions、<span class="token constant">CSS3</span> <span class="token number">3</span>D     transforms、Opacity、Canvas、WebGL、Video）会触发<span class="token constant">GPU</span>渲染，请合理使用。过渡使用会引发手机过耗电增加
    <span class="token constant">PC</span>端的在移动端同样适用
</code></pre></div><h2 id="js-继承方式及其优缺点"><a href="#js-继承方式及其优缺点" class="header-anchor">#</a> js 继承方式及其优缺点</h2> <div class="language-js extra-class"><pre class="language-js"><code>原型链继承的缺点<span class="token operator">:</span>
    意识字面量重写原型绘中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数
<span class="token function">借用构造函数</span><span class="token punctuation">(</span>类式继承<span class="token punctuation">)</span>
    借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起，因此需要原型链<span class="token operator">+</span>借用构造函数的模式<span class="token operator">--</span><span class="token operator">-</span>组合继承
    这是一种比较常见的继承方法，背后的思路是使用原型链实现对原型属性和方法的继承
</code></pre></div><h2 id="http-2-0"><a href="#http-2-0" class="header-anchor">#</a> HTTP 2.0</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">2</span>引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。
<span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">2</span>提供更多的加密支持
<span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">2</span>使用多路技术，允许多个消息在一个连接上同事交差
<span class="token function">增加了头压缩</span><span class="token punctuation">(</span>header compression<span class="token punctuation">)</span><span class="token punctuation">,</span>因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽
</code></pre></div><h2 id="defer-与-async"><a href="#defer-与-async" class="header-anchor">#</a> defer 与 async</h2> <div class="language-js extra-class"><pre class="language-js"><code>defer并行加载js文件，会按照页面上script标签的顺序执行
<span class="token keyword">async</span>并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行
</code></pre></div><h2 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h2> <div class="language-js extra-class"><pre class="language-js"><code>工厂模式
    主要好处：可以消除对象间的耦合，通过使用工程方法而不是<span class="token keyword">new</span>关键字，将所有实例化的代码集中在一个位置防止代码重复
    工厂模式解决了重复实例化的问题，但存在识别问题：无法弄清楚他们到底是哪一个对象的实例
    <span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>profession</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//集中实例化的函数var obj = new Object();</span>
        obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        obj<span class="token punctuation">.</span>profession <span class="token operator">=</span> profession<span class="token punctuation">;</span>
        obj<span class="token punctuation">.</span><span class="token function-variable function">move</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' at '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">' engaged in '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>profession<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> test1 <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token string">'trigkit4'</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token string">'programmer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例</span>

构造函数模式
    使用构造函数的方法，即解决了重复实例化的问题，有解决了对象识别的 问题，该模式与工厂模式的不同之处在于：
    <span class="token number">1</span><span class="token function">、构造函数方法没有显示的创建对象</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token number">2</span>、直接将属性和方法赋值给<span class="token keyword">this</span>对象
    <span class="token number">3</span>、没有<span class="token keyword">return</span>
</code></pre></div><h2 id="对闭包的理解"><a href="#对闭包的理解" class="header-anchor">#</a> 对闭包的理解</h2> <p>使用闭包主要是为了设计私有的变量和方法，闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露，在 js 中，函数即闭包，只有函数才会产生作用域的概念</p> <div class="language-js extra-class"><pre class="language-js"><code>闭包有三个特性
    <span class="token number">1</span>、函数嵌套函数
    <span class="token number">2</span>、函数内部可以引用外部的参数和变量
    <span class="token number">3</span>、参数和变量不会被垃圾回收机制回收
</code></pre></div><h2 id="cookie-的弊端"><a href="#cookie-的弊端" class="header-anchor">#</a> cookie 的弊端</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">1/7/2020, 3:40:32 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/weber/typescript/react+ts.html" class="prev">
        react+ts 学习笔记
      </a></span> <span class="next"><a href="/weber/other/基于飞冰的微前端实践.html">
        微前端
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div class="cat-container" data-v-a13867c0><canvas id="vuepress-cat" width="280" height="250" class="live2d" data-v-a13867c0></canvas></div></div></div>
    <script src="/assets/js/app.d5333c69.js" defer></script><script src="/assets/js/2.dd63acd8.js" defer></script><script src="/assets/js/34.7575c096.js" defer></script>
  </body>
</html>
