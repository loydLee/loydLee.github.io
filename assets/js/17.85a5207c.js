(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{412:function(e,t,n){"use strict";n.r(t);var s=n(26),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"js-基础拾遗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-基础拾遗"}},[e._v("#")]),e._v(" js 基础拾遗")]),e._v(" "),n("hr"),e._v(" "),n("h2",{attrs:{id:"null-和-undefined-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-的区别"}},[e._v("#")]),e._v(" null 和 undefined 的区别")]),e._v(" "),n("ul",[n("li",[e._v("null 表示一个“无”的对象，转为数值时为 0，undefined 则是一个表示“无”的原始值，转化为数值时是 NaN")]),e._v(" "),n("li",[e._v("null 表示灭有对象，也就是该处不应该有值，可用为函数参数表示该参数不是对象，也可以作为原型链的重点")]),e._v(" "),n("li",[e._v("undefined 表示缺少值，本应有值只是暂未定义，即变量声明了，但是还没有赋值，调用函数时候，本应该提供的参数没有提供，对象没有赋值的属性，该属性值为 undefined，函数没有返回值时，默认返回 undefined")])]),e._v(" "),n("h2",{attrs:{id:"事件流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件流"}},[e._v("#")]),e._v(" 事件流")]),e._v(" "),n("p",[e._v("描述页面中接收事件的顺序，DOM 2 级事件流包括下面几个阶段")]),e._v(" "),n("ul",[n("li",[e._v("事件捕获阶段")]),e._v(" "),n("li",[e._v("处于目标阶段")]),e._v(" "),n("li",[e._v("事件冒泡阶段")])]),e._v(" "),n("p",[e._v("在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间")]),e._v(" "),n("h3",{attrs:{id:"addeventlistener"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#addeventlistener"}},[e._v("#")]),e._v(" addEventListener")]),e._v(" "),n("p",[e._v("语法：target.addEventListener(type, listener, options/useCapture)")]),e._v(" "),n("ul",[n("li",[e._v("type:表示监听事件类型的字符串")]),e._v(" "),n("li",[e._v("listener：所监听的事件触发，会接受一个事件通知对象。")]),e._v(" "),n("li",[e._v("options：一个指定有关 listener 属性的可选参数对象。可选值有 capture（事件捕获阶段传播到这里触发）、once（在 listener 添加之后最多值调用一次）、passive（设置为 true 时表示 listener 永远不会调用 preventDefault()）。")]),e._v(" "),n("li",[e._v("useCapture：在 DOM 树中，注册了 listener 的元素，是否要先于它下面的 EventTarget 调用该 listener。\n"),n("em",[e._v("ps")]),e._v(":第三个参数涉及到冒泡以及捕获，true 时为捕获，false 为冒泡，参数为一个对象对象 { passive: true }，针对 Safari 浏览器，禁止/开启使用滚动时候用到")])]),e._v(" "),n("h3",{attrs:{id:"原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),n("p",[e._v("原本是网景（Netscape）和 IE 对 DOM 事件产生描述的差异，w3c 对方案进行了统一，规定将 DOM 事件分为两个阶段：当一个元素被点击。首先是事件捕获阶段，window 最先接收事件，然后一层一层向下捕获，最后由具体元素接收，之后再由具体元素一层一层往上冒泡，到 window 接收事件")]),e._v(" "),n("ul",[n("li",[e._v("事件冒泡：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发（当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了 click 事件就触发父元素的 click）")]),e._v(" "),n("li",[e._v("事件捕获：和冒泡相反，会从上层传递到下层\n"),n("strong",[e._v("点击一个 input 依次触发")]),e._v("：onmouseenter -> onmousedown -> onfocus -> onmouseup -> onclick")])]),e._v(" "),n("h3",{attrs:{id:"阻止冒泡"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#阻止冒泡"}},[e._v("#")]),e._v(" 阻止冒泡")]),e._v(" "),n("ul",[n("li",[e._v("event.stopPropagation()")])]),e._v(" "),n("p",[n("strong",[e._v("并不是所有事件都有冒泡")]),e._v("：onblur onfocus onmouseenter onmouseleave")]),e._v(" "),n("h2",{attrs:{id:"typeof-和-instanceof-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#typeof-和-instanceof-的区别"}},[e._v("#")]),e._v(" typeof 和 instanceof 的区别")]),e._v(" "),n("ul",[n("li",[e._v("typeof：对某个变量类型的检测，基本类型除了 null 之外，都能正常地显示为对应的类型，引用类型除了函数会显示为 function，其他都显示为 object。")]),e._v(" "),n("li",[e._v("instanceof 主要用于检测某个构造函数的原型对象在不在某个对象的原型链上。\nps:typeof 会对 null 显示错误是个历史 Bug，typeof null 输出的是 object，因为 JavaScript 早起版本是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以它错误判断为 object。")])]),e._v(" "),n("h2",{attrs:{id:"对-this-的理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对-this-的理解"}},[e._v("#")]),e._v(" 对 this 的理解")]),e._v(" "),n("p",[e._v("对函数来说，this 指向调用最后调用函数的对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用，对于全局来说，this 指向 window")]),e._v(" "),n("h2",{attrs:{id:"js-定位相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-定位相关"}},[e._v("#")]),e._v(" js 定位相关")]),e._v(" "),n("ul",[n("li",[n("em",[e._v("clientHeight")]),e._v("：表示可视区域的高度，不包含 border 和滚动条")]),e._v(" "),n("li",[n("em",[e._v("offsetHeight")]),e._v("：表示可视区域的高度，包含了 border 和滚动条")]),e._v(" "),n("li",[n("em",[e._v("scrollHeight")]),e._v("：表示了所有区域的高度，包含了因为滚动被隐藏的部分")]),e._v(" "),n("li",[n("em",[e._v("clientTop")]),e._v("：表示边框 border 的厚度，在未指定的情况下一般为 0")]),e._v(" "),n("li",[n("em",[e._v("scrollTop")]),e._v("：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标（CSS 定位的元素或 body 元素）距离顶端的高度。")])]),e._v(" "),n("h2",{attrs:{id:"函数式编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[e._v("#")]),e._v(" 函数式编程")]),e._v(" "),n("p",[e._v("通过对面对对象式编程拆分，将各个功能独立出来，从而达到功能独立，易复用等目的，可以简单理解成函数式编程就是对可以抽离的功能进行抽取封装\n"),n("strong",[e._v("特点")])]),e._v(" "),n("ul",[n("li",[e._v("函数是一等公民")]),e._v(" "),n("li",[e._v("声明做某件事情：重要的是做什么，而不是怎么做")]),e._v(" "),n("li",[e._v("便于垃圾回收")]),e._v(" "),n("li",[e._v("数据不可变")]),e._v(" "),n("li",[e._v("无状态")]),e._v(" "),n("li",[e._v("无副作用")])]),e._v(" "),n("h2",{attrs:{id:"规范化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#规范化"}},[e._v("#")]),e._v(" 规范化")]),e._v(" "),n("h3",{attrs:{id:"commonjs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" CommonJS")]),e._v(" "),n("ul",[n("li",[e._v("导出：module.exports = {}、exports.xxx = 'xxx'")]),e._v(" "),n("li",[e._v("导入：require(./index.js)")]),e._v(" "),n("li",[e._v("查找方式：查找当前目录是否具有文件，没有则查找当前目录的 node*modules 文件。再没有，冒泡查询，一直往系统中的 npm 目录查找。\n"),n("em",[e._v("优点")]),e._v("\n1、所有代码在模块作用域内运行，不会污染其他文件\n2、require 得到的值是值得拷贝，即使我们引用其他 js 文件的变量，修改操作了也不会影响其他文件\n*缺陷_\n1、应用层面，在 index.html 中做 var index = require('./index.js')操作会报错，因为它最终是后台执行的，只能是 index.js 引用 index2.js 这种方式\n2、同步加载问题，CommonJS 规范中模块是同步加载的，即在 index.js 中加载 index2.js，如果 index2.js 卡住了，会导致阻塞")])]),e._v(" "),n("h3",{attrs:{id:"amd-asynchronous-module-definition"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#amd-asynchronous-module-definition"}},[e._v("#")]),e._v(" AMD-Asynchronous Module Definition")]),e._v(" "),n("p",[e._v("基于 CommonJS,可以采用异步方式加载模块，“异步模块定义”，async")]),e._v(" "),n("h3",{attrs:{id:"cmd-common-module-definition"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cmd-common-module-definition"}},[e._v("#")]),e._v(" CMD-Common Module Definition")]),e._v(" "),n("p",[e._v("sea.js 推崇的规范，CMD 依赖就近，用的时候再 require")]),e._v(" "),n("p",[e._v("AMD 和 CMD 最大的区别是对依赖模块执行时机处理不同，但是两者皆为异步加载")]),e._v(" "),n("h3",{attrs:{id:"es6-module"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6-module"}},[e._v("#")]),e._v(" ES6 Module")]),e._v(" "),n("ul",[n("li",[e._v("导出\n1、export a\n2、export { a }\n3、export { a as jsliang }\n4、export default function() {}")]),e._v(" "),n("li",[e._v("导入\n1、import './index'\n2、import { a } from './index.js'\n3、import { a as jsliang } from './index.js'\n4、import * as index from './index.js'")])]),e._v(" "),n("p",[e._v("-特点：\n1、export 命令和 import 命令可以出现在模块的任何位置，只要处于模块顶层就可以。 如果处于块级作用域内，就会报错，这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。\n2、import 命令具有提升效果，会提升到整个模块的头部，首先执行。")]),e._v(" "),n("ul",[n("li",[e._v("和 CommonJS 区别：")])]),e._v(" "),n("p",[e._v("1、CommonJS 模块是运行时加载，ES6 Modules 是编译时输出接口\n2、CommonJS 输出是值的拷贝；ES6 Modules 输出的是值的引用，被输出模块的内部的改变会影响引用的改变\n3、CommonJs 导入的模块路径可以是一个表达式，因为它使用的是 require() 方法；而 ES6 Modules 只能是字符串\n4、CommonJS this 指向当前模块，ES6 Modules 的 this 指向 undefined\n5、ES6 Modules 中没有这些顶层变量：arguments、require、module、exports、_filename、_dirname")])])}),[],!1,null,null,null);t.default=i.exports}}]);